package {{ .PackageName }}

import (
  "context"
  "text/template"
  "database/sql"

  "github.com/jmoiron/sqlx"
	"gopkg.in/guregu/null.v3"
)

{{ range $stmt := .Stmts }}

  {{ $stmtName := $stmt.StmtName }}
  {{ $stmtType := $stmt.StmtType }}
  {{ $argInfo := ExtractArgInfo $stmt }}
  {{ $varInfo := ExtractVarInfo $stmt }}
  {{ $wildcardInfo := ExtractWildcardInfo $stmt }}

  {{ if eq $stmtType "SELECT" }}

    {{ $noTemplate := $varInfo.Has "no_template" }}
    {{ $inQuery := $varInfo.Has "in_query" }}

// {{ $stmtName }}Result is the result of {{ $stmtName }}.
type {{ $stmtName }}Result struct {
    {{ range $i, $resultColumnName := $stmt.ResultColumnNames -}}

      {{ $resultColumnType := $stmt.ResultColumnType $i -}}
      {{ $wildcardColumn := $wildcardInfo.WildcardColumn $i -}}

      {{ if $wildcardColumn.Valid -}}
        {{ if eq $wildcardColumn.Pos 0 -}}
  {{ UpperCamel $wildcardColumn.Table.TableName }} {{ UpperCamel $wildcardColumn.Table.TableName }}
        {{ end -}}
      {{ else -}}
  {{ UpperCamel $resultColumnName }} {{ ScanType $resultColumnType }}
      {{ end -}}

    {{ end -}}
}

func (r *{{ $stmtName }}Result) scanFrom(rows *sql.Rows) error {
  return rows.Scan(
{{ range $i, $resultColumnName := $stmt.ResultColumnNames -}}
  {{ $wildcardColumn := $wildcardInfo.WildcardColumn $i -}}
  {{ if $wildcardColumn.Valid -}}
  &r.{{ UpperCamel $wildcardColumn.Table.TableName }}.{{ UpperCamel $wildcardColumn.ColumnName }},
  {{ else -}}
  &r.{{ UpperCamel $resultColumnName }},
  {{ end -}}
{{ end -}}
  )
}

var (
{{ if $noTemplate -}}
  stmt{{ $stmtName }} = {{ Literal $stmt.StmtText }} 
{{ else -}}
  stmtTmpl{{ $stmtName }} = template.Must(template.New("{{ $stmtName }}").Parse({{ Literal $stmt.StmtText }}))
{{ end -}}
)

func {{ $stmtName }}(ctx context.Context, q Queryer
{{- range $i := N $argInfo.NumArg -}}
  {{- $argName := $argInfo.ArgName $i -}}
  {{- $argType := $argInfo.ArgType $i -}}
, {{ $argName }} {{ $argType }}
{{- end -}}
) ([]*{{ $stmtName }}Result, error) {

  // Data
  data_ := map[string]interface{}{
{{ range $i := N $argInfo.NumArg -}}
  {{- $argName := $argInfo.ArgName $i -}}
    "{{ $argName }}": {{ $argName }},
{{- end }}
  }

{{ if $noTemplate }}
  // Named query.
  namedQueryString_ := stmt{{ $stmtName }}
{{ else }}
  // Template -> named query
  namedQuery_ := newWriterStringer()
  if err_ := stmtTmpl{{ $stmtName }}.Execute(namedQuery_, data_); err_ != nil {
    return nil, err_
  }
  namedQueryString_ := namedQuery_.String()
{{ end }}

  // Named query -> query
  query_, args_, err_ := sqlx.Named(namedQueryString_, data_)
  if err_ != nil {
    return nil, err_
  }

{{ if $inQuery }}
  // Expand "in" args.
  query_, args_, err_ = sqlx.In(query_, args_)
  if err_ != nil {
    return nil, err_
  }
{{ end }}

  // Query
  rows_, err_ := q.QueryContext(ctx, query_, args_)
  if err_ != nil {
    return nil, err_
  }
  defer rows_.Close()

  // Results
  results_ := []*{{ $stmtName }}Result{}
  for rows_.Next() {
    result_ := &{{ $stmtName }}Result{}
    if err_ := result_.scanFrom(rows_); err_ != nil {
      return nil, err_
    }
    results_ = append(results_, result_)
  }
  if err_ := rows_.Err(); err_ != nil {
    return nil, err_
  }
  
  return results_, nil
}


  {{ else if eq $stmtType "UPDATE" }}


  {{ else if eq $stmtType "DELETE" }}


  {{ else if eq $stmtType "INSERT" }}


  {{ else }}

  {{ end }}

{{ end }}
